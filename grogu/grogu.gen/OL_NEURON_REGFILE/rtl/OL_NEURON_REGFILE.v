// Generated by  grogu  starting from JINJA templated  MODULE_TEMPLATE_NATIVE.v  file

`default_nettype none

`include "OL_NEURON_REGFILE.vh"

// Native interface based design for large and distributed register files (used in conjunction with
// the SCI configuration ring)
module OL_NEURON_REGFILE (
    // Clock and reset
    input wire CLK,
    input wire RSTN,
    // Register interface
    input wire WREQ,
    input wire [3:0] WADDR,
    input wire [7:0] WDATA,
    output wire WACK,
    input wire RREQ,
    input wire [3:0] RADDR,
    output wire [7:0] RDATA,
    output wire RVALID,
    // Register bundles
    output wire [7:0] HWIF_OUT_WEIGHT_0,
    output wire [7:0] HWIF_OUT_WEIGHT_1,
    output wire [7:0] HWIF_OUT_WEIGHT_2,
    output wire [7:0] HWIF_OUT_WEIGHT_3,
    output wire [7:0] HWIF_OUT_WEIGHT_4,
    output wire [7:0] HWIF_OUT_WEIGHT_5,
    output wire [7:0] HWIF_OUT_WEIGHT_6,
    output wire [7:0] HWIF_OUT_WEIGHT_7,
    output wire [7:0] HWIF_OUT_BIAS
);

    reg rvalid;
    reg [7:0] rdata;
    reg wack;

    // Instantiate registers and declare their own signals. From a Software perspective, i.e. access
    // via the AXI4 Lite interface, Configuration registers are Write-only while Status and Delta
    // registers are Read-only

    // WEIGHT_0: Input weight 0
    reg weight_0_wreq;
    wire [7:0] weight_0_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_0_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_0_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_0_value_out)
    );
        
    // WEIGHT_1: Input weight 1
    reg weight_1_wreq;
    wire [7:0] weight_1_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_1_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_1_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_1_value_out)
    );
        
    // WEIGHT_2: Input weight 2
    reg weight_2_wreq;
    wire [7:0] weight_2_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_2_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_2_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_2_value_out)
    );
        
    // WEIGHT_3: Input weight 3
    reg weight_3_wreq;
    wire [7:0] weight_3_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_3_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_3_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_3_value_out)
    );
        
    // WEIGHT_4: Input weight 4
    reg weight_4_wreq;
    wire [7:0] weight_4_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_4_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_4_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_4_value_out)
    );
        
    // WEIGHT_5: Input weight 5
    reg weight_5_wreq;
    wire [7:0] weight_5_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_5_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_5_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_5_value_out)
    );
        
    // WEIGHT_6: Input weight 6
    reg weight_6_wreq;
    wire [7:0] weight_6_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_6_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_6_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_6_value_out)
    );
        
    // WEIGHT_7: Input weight 7
    reg weight_7_wreq;
    wire [7:0] weight_7_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    WEIGHT_7_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (weight_7_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (weight_7_value_out)
    );
        
    // BIAS: Input bias
    reg bias_wreq;
    wire [7:0] bias_value_out;
    RW_REG #(
        .DATA_WIDTH (8),
        .HAS_RESET  (0)
    )
    BIAS_REG (
        .CLK        (CLK),
        .RSTN       (RSTN),
        .WEN        (bias_wreq),
        .VALUE_IN   (WDATA),
        .VALUE_OUT  (bias_value_out)
    );
        
    // Write decoder
    always @(posedge CLK) begin
        wack <= 1'b0;
        weight_0_wreq <= 1'b0;
        weight_1_wreq <= 1'b0;
        weight_2_wreq <= 1'b0;
        weight_3_wreq <= 1'b0;
        weight_4_wreq <= 1'b0;
        weight_5_wreq <= 1'b0;
        weight_6_wreq <= 1'b0;
        weight_7_wreq <= 1'b0;
        bias_wreq <= 1'b0;

        if(WREQ) begin
            wack <= 1'b1;

            case(WADDR)
               `OL_NEURON_REGFILE_WEIGHT_0_OFFSET : begin weight_0_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_1_OFFSET : begin weight_1_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_2_OFFSET : begin weight_2_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_3_OFFSET : begin weight_3_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_4_OFFSET : begin weight_4_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_5_OFFSET : begin weight_5_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_6_OFFSET : begin weight_6_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_WEIGHT_7_OFFSET : begin weight_7_wreq <= 1'b1; end
               `OL_NEURON_REGFILE_BIAS_OFFSET : begin bias_wreq <= 1'b1; end
            endcase
        end
    end

    // Create Read strobe from Read request edge
    always @(posedge CLK) begin
        rvalid <= RREQ;
    end

    // Read decoder
    always @(RADDR) begin
        case(RADDR)
            `OL_NEURON_REGFILE_WEIGHT_0_OFFSET : begin rdata = weight_0_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_1_OFFSET : begin rdata = weight_1_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_2_OFFSET : begin rdata = weight_2_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_3_OFFSET : begin rdata = weight_3_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_4_OFFSET : begin rdata = weight_4_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_5_OFFSET : begin rdata = weight_5_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_6_OFFSET : begin rdata = weight_6_value_out; end
            `OL_NEURON_REGFILE_WEIGHT_7_OFFSET : begin rdata = weight_7_value_out; end
            `OL_NEURON_REGFILE_BIAS_OFFSET : begin rdata = bias_value_out; end
            default : begin rdata = {8{1'b1}}; end
        endcase
    end

    // Pinout
    assign RVALID   = rvalid;
    assign RDATA    = rdata;
    assign WACK     = wack;

    // Compose and decompose CSR bundle data. Control registers (those written by the Software and
    // read by the Hardware) are put over the  HWIF_OUT_*  ports; Status registers (those written by
    // the Hardware and read by the Software) are get over the  HWIF_IN_*  ports
    assign HWIF_OUT_WEIGHT_0 = weight_0_value_out;
    assign HWIF_OUT_WEIGHT_1 = weight_1_value_out;
    assign HWIF_OUT_WEIGHT_2 = weight_2_value_out;
    assign HWIF_OUT_WEIGHT_3 = weight_3_value_out;
    assign HWIF_OUT_WEIGHT_4 = weight_4_value_out;
    assign HWIF_OUT_WEIGHT_5 = weight_5_value_out;
    assign HWIF_OUT_WEIGHT_6 = weight_6_value_out;
    assign HWIF_OUT_WEIGHT_7 = weight_7_value_out;
    assign HWIF_OUT_BIAS = bias_value_out;
endmodule

`default_nettype wire